package com.geek.week3;

public class ConstructBinaryTreePreorderInorderTraversal {
    int pre =0;
    int in =0;
    public TreeNode1 buildTree(int[] preorder, int[] inorder) {
        return buildTreeHelper(preorder,inorder,(long)Integer.MAX_VALUE+1);
    }
    private TreeNode1 buildTreeHelper(int[] preorder, int[] inorder, long stop){
        //到达末尾返回 null
        if(pre == preorder.length){
            return null;
        }
        //到达停止点返回 null
        //当前停止点已经用了，in 后移
        if (inorder[in] == stop) {
            in++;
            return null;
        }
        int root_val = preorder[pre++];
        TreeNode1 root = new TreeNode1(root_val);
        //左子树的停止点是当前的根节点
        root.left = buildTreeHelper(preorder,  inorder, root_val);
        //右子树的停止点是当前树的停止点
        root.right = buildTreeHelper(preorder, inorder, stop);
        return root;
    }
}

class TreeNode1 {
    int val;
    TreeNode1 left;
    TreeNode1 right;

    TreeNode1() {
    }

    TreeNode1(int val) {
        this.val = val;
    }

    TreeNode1(int val, TreeNode1 left, TreeNode1 right) {
        this.val = val;
        this.left = left;
        this.right = right;
    }
}
